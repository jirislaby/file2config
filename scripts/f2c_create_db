#!/usr/bin/perl
# SPDX-License-Identifier: GPL-2.0-only

use strict;
use warnings;
use File::pushd qw(pushd);
use File::Find qw(find);
use File::Basename qw(fileparse);
use File::Path qw(make_path);
use File::Spec qw(abs2rel);
use FindBin qw($Bin);
use DBI qw(:sql_types);
use DBD::SQLite::Constants qw(SQLITE_CONSTRAINT_UNIQUE);
use Git;
use Getopt::Long qw(GetOptions);
use POSIX qw(sysconf _SC_ARG_MAX setlocale LC_COLLATE);
use Term::ANSIColor qw(colored);

setlocale(LC_COLLATE, 'C.UTF-8');

my @branches;
my $db;
my $kerncvs = 'kerncvs.suse.de:/srv/git/kernel-source.git';
my $force = 0;
my $max_arg = POSIX::sysconf(&POSIX::_SC_ARG_MAX) || 128 << 10;
my $output = 'conf_file_map.sqlite';
my $dump_refs;
my $refresh = '';
my $report_unhandled;
my $scratch_area = $ENV{'SCRATCH_AREA'};

GetOptions(
	'branch=s' => \@branches,
	'dest=s' => \$scratch_area,
	'dump_refs' => \$dump_refs,
	'force' => \$force,
	'output=s' => \$output,
	'refresh' => \$refresh,
	'unhandled' => \$report_unhandled,
) or die("Error in command line arguments: $0");

if (defined $scratch_area) {
	$scratch_area .= '/fill-db';
} else {
	print colored(qq(SCRATCH_AREA not defined (defaulting to "fill-db")\n), 'yellow');
	$scratch_area = 'fill-db';
}

make_path $scratch_area;

my @ref;
if (defined $ENV{'KSOURCE_GIT'} && -d $ENV{'KSOURCE_GIT'}) {
	push @ref, ('--reference', $ENV{'KSOURCE_GIT'});
} else {
	print colored("KSOURCE_GIT not defined, cloning shallow tree from kerncvs\n", 'yellow');
}

my $our_ksource_git = "$scratch_area/kernel-source";
if (! -d $our_ksource_git) {
	Git::command_noisy('clone', '--depth', '1', '--no-tags',
		'-b', 'scripts', @ref, $kerncvs, $our_ksource_git);
	my $dir = pushd $our_ksource_git;
	system('./scripts/install-git-hooks') == 0 or
		die 'cannot install hooks';
}

my $git = Git->repository(Directory => $our_ksource_git);

$git->command_noisy('fetch', '-q', 'origin', 'scripts');
$git->command_noisy('checkout', '-q', "origin/scripts");

if (!@branches) {
	open(my $b, '-|', '/usr/bin/bash', '-c',
		qq(. "$our_ksource_git/scripts/common-functions"\n) .
		'branches_conf="$(fetch_branches "' . $refresh . '")"
		for_each_build_branch "$branches_conf" echo') or
		die 'cannot exec bash';
	@branches = map { chomp; $_ } <$b>;
	close $b;
}
my %in_branches = map { $_ => 1 } @branches;
$in_branches{'scripts'} = 1;

my @local = map { s@^\s*origin/@@; $_; } $git->command('branch', '-r');
my @to_del = grep { not $in_branches{$_} } @local;
@to_del = map { "origin/$_" } @to_del;
# otherwise fetch fails on deleted branches even when we do not mention them
if (@to_del) {
	$git->command_noisy('branch', '-D', '-r', @to_del);
}

my @fetches = map { "+$_:refs/remotes/origin/$_" } @branches;
$git->command_noisy('fetch', '-q', 'origin', @fetches);

$db = DBI->connect("dbi:SQLite:dbname=$output", undef, undef,
	{ sqlite_extended_result_codes	=> 1 }) or
	die "connect to db error: " . DBI::errstr;

$db->do('PRAGMA foreign_keys = ON;') or
	die "cannot enable foreign keys";

my @tables = (
	[ 'branch', 'id INTEGER PRIMARY KEY', 'branch TEXT NOT NULL UNIQUE',
		'sha TEXT NOT NULL' ],
	[ 'config', 'id INTEGER PRIMARY KEY', 'config TEXT NOT NULL UNIQUE' ],
	[ 'dir', 'id INTEGER PRIMARY KEY', 'dir TEXT NOT NULL UNIQUE' ],
	[ 'file', 'id INTEGER PRIMARY KEY', 'file TEXT NOT NULL',
		'dir INTEGER NOT NULL REFERENCES dir(id)',
		'UNIQUE(file, dir)' ],
	[ 'conf_file_map', 'id INTEGER PRIMARY KEY',
		'branch INTEGER NOT NULL REFERENCES branch(id) ON DELETE CASCADE',
		'config INTEGER NOT NULL REFERENCES config(id) ON DELETE CASCADE',
		'file INTEGER NOT NULL REFERENCES file(id) ON DELETE CASCADE',
		'UNIQUE(branch, config, file)' ],
	[ 'user', 'id INTEGER PRIMARY KEY',
		'email TEXT NOT NULL UNIQUE' ],
	[ 'user_file_map',
		'user INTEGER NOT NULL REFERENCES user(id) ON DELETE CASCADE',
		'file INTEGER NOT NULL REFERENCES file(id) ON DELETE CASCADE',
		'branch INTEGER NOT NULL REFERENCES branch(id) ON DELETE CASCADE',
		'count INTEGER NOT NULL',
		'count_no_fixes INTEGER NOT NULL',
		'UNIQUE(user, branch, file)' ],
);

foreach my $entry (@tables) {
	my $name = shift @{$entry};
	my $desc = join ', ', @{$entry};
	$db->do("CREATE TABLE IF NOT EXISTS $name($desc) STRICT;") or
		die "cannot create table '$name'";
}

$db->do('CREATE INDEX IF NOT EXISTS conf_file_map_file_index ON conf_file_map(file);') or
	die "cannot create conf_file_map_file_index";
$db->do('CREATE VIEW IF NOT EXISTS conf_file_map_view_raw_file AS ' .
	'SELECT conf_file_map.id, branch.branch, config.config, conf_file_map.file ' .
	'FROM conf_file_map ' .
	'LEFT JOIN branch ON conf_file_map.branch=branch.id ' .
	'LEFT JOIN config ON conf_file_map.config=config.id;') or
	die "cannot create conf_file_map_view_raw_file";
$db->do('CREATE VIEW IF NOT EXISTS conf_file_map_view AS ' .
	q(SELECT map.id, map.branch, map.config, dir.dir || '/' || file.file AS path ) .
	'FROM conf_file_map_view_raw_file AS map ' .
	'LEFT JOIN file ON map.file=file.id ' .
	'LEFT JOIN dir ON file.dir=dir.id;') or
	die "cannot create conf_file_map_view";
$db->do('CREATE VIEW IF NOT EXISTS user_file_map_view AS ' .
	q(SELECT user.email, branch.branch, dir.dir || '/' || file.file AS path, ) .
		'map.count, map.count_no_fixes ' .
	'FROM user_file_map AS map ' .
	'LEFT JOIN user ON map.user=user.id ' .
	'LEFT JOIN branch ON map.branch=branch.id ' .
	'LEFT JOIN file ON map.file=file.id ' .
	'LEFT JOIN dir ON file.dir=dir.id;') or
	die "cannot create conf_file_map_view";
$db->do('CREATE VIEW IF NOT EXISTS user_file_map_view_grouped AS ' .
	'SELECT email, path, SUM(count) AS count, ' .
		'SUM(count_no_fixes) AS count_no_fixes ' .
	'FROM user_file_map_view AS map GROUP BY email, path') or
	die "cannot create user_file_map_view_grouped";

my $ins_branch = $db->prepare('INSERT INTO branch(branch, sha) VALUES (?, ?);') or
	die "cannot prepare branch";
my $ins_config = $db->prepare('INSERT INTO config(config) VALUES (?);') or
	die "cannot prepare config";
my $ins_dir = $db->prepare('INSERT INTO dir(dir) VALUES (?);') or
	die "cannot prepare dir";
my $ins_file = $db->prepare('INSERT INTO file(file, dir) ' .
	'SELECT ?, dir.id FROM dir WHERE dir.dir=?;') or
	die "cannot prepare file";
my $ins_cfmap = $db->prepare('INSERT INTO conf_file_map(branch, config, file) ' .
	'SELECT branch.id, config.id, file.id FROM branch, config, file ' .
		'LEFT JOIN dir ON file.dir = dir.id ' .
		'WHERE branch.branch=? AND config.config=? AND ' .
		'file.file=? AND dir.dir=?;') or
	die "cannot prepare cfmap";

my $ins_user = $db->prepare('INSERT INTO user(email) VALUES (?);') or
	die "cannot prepare user";
my $ins_ufmap = $db->prepare('INSERT INTO user_file_map(user, branch, file, count, count_no_fixes) ' .
	'SELECT user.id, branch.id, file.id, ?, ? FROM user, branch, file ' .
		'LEFT JOIN dir ON file.dir = dir.id ' .
		'WHERE user.email=? AND branch.branch=? AND ' .
			'file.file=? AND dir.dir=?;') or
	die "cannot prepare ufmap";

# we handle UNIQUE failures of these below
$ins_config->{PrintError} = 0;
$ins_dir->{PrintError} = 0;
$ins_file->{PrintError} = 0;
$ins_user->{PrintError} = 0;

sub process_files($$) {
	my ($branch, $branch_tree) = @_;
	my $dir = pushd $branch_tree;
	open(my $f2c, '-|', 'f2c_collect_configs', '-q') or
		die 'cannot run f2c_collect_configs';
	while (<$f2c>) {
		chomp;
		next if /^ignoring already reported/;

		my ($config, $src) = /^XXX (\S+)\s+(\S+)$/;
		die "wrong output of f2c_collect_configs: '$_'" unless defined $config;

		next if ($src =~ /(?:Documentation|samples|tools)\//);
		next if ($src !~ '\.c$');

		$src = File::Spec->abs2rel($src, $branch_tree);
		my ($file, $dir) = fileparse($src);
		$dir =~ s|/$||;
		$ins_config->execute($config) or
			$ins_config->err == SQLITE_CONSTRAINT_UNIQUE or
			die "cannot execute ins_config: " . $db->errstr;
		$ins_dir->execute($dir) or
			$ins_dir->err == SQLITE_CONSTRAINT_UNIQUE or
			die "cannot execute ins_dir: " . $db->errstr;
		$ins_file->execute($file, $dir) or
			$ins_file->err == SQLITE_CONSTRAINT_UNIQUE or
			die "cannot execute ins_file: " . $db->errstr;
		$ins_cfmap->execute($branch, $config, $file, $dir) or
			$ins_cfmap->err == SQLITE_CONSTRAINT_UNIQUE or
			die "cannot execute ins_cfmap for ($branch, $config, $file, $dir)";
	}
	close $f2c;
}

sub process_authors($) {
	my ($branch) = @_;
	my %HoH;
	my %HoH_real;
	my %HoH_refs;

	my $re_interesting = qr/^\s*(?:From|Cc|Co-developed-by|Acked|Acked-by|Modified-by|Reviewed-by|Reviewed-and-tested-by|Signed-off-by):.*[\s<]([a-z0-9_.-]+\@suse\.[a-z]+)/i;
	my $re_false = qr/(?:lore|lkml)\.kernel|patchwork\.ozlabs|^\[|^(?:Debugged-by|Evaluated-by|Improvements-by|Link|Message-ID|Patch-mainline|Reported-and-tested-by|Reported-by|Return-path|Suggested-by|Tested-by):|thanks|:$/i;

	my $dir = pushd $our_ksource_git;
	foreach my $patch_file ($git->command(qw|ls-tree --name-only @ patches.suse/|)) {
		#print "$patch_file\n";
		open(my $patch, "<", $patch_file) or die "cannot open $patch_file";
		my %patch_emails;
		my %patch_refs;
		my $git_fixes;
		while (my $line = <$patch>) {
			chomp $line;
			if (my ($email) = $line =~ $re_interesting) {
				$patch_emails{$email} = 1;
				next;
			}
			last if ($line =~ /^---/);
			if ($line =~ /^References:.*(?ix:
					(?:git|stable)[- ]fixes |
					stable-\d |
					b[ns]c[#](?:1012628|1051510|1151927|1152489))/) {
				$git_fixes = 1;
			} elsif ($dump_refs) {
				if (my ($refs) = $line =~ /^References: (.*)/) {
					foreach my $ref (split /[\s,;]+/, $refs) {

						$patch_refs{$ref} = 1;
					}
				}
			}

			if ($report_unhandled && $line =~ /\@suse\./ &&
					$line !~ $re_false) {
				print STDERR "$patch_file: unhandled e-mail in '$line'\n"
			}
		}

		foreach my $ref (keys %patch_refs) {
			foreach my $email (keys %patch_emails) {
				$HoH_refs{$email}->{$ref}++ if ($ref !~ /FATE#|CVE-|jsc#|XSA-/i);
			}
		}

		while (my $line = <$patch>) {
			chomp $line;
			if (my ($file) = $line =~ /^\+\+\+ b\/(.*\.[ch])/) {
				print STDERR "$patch_file: $file\n" if ($file =~ /^\/dev/);
				foreach my $email (keys %patch_emails) {
					$HoH{$email}->{$file}++;
					if (!$git_fixes) {
						$HoH_real{$email}->{$file}++;
					}
				}
				next;
			}
		}
		close $patch;
	}

	foreach my $email (sort keys %HoH_refs) {
		foreach my $ref (sort keys %{$HoH_refs{$email}}) {
			if ($HoH_refs{$email}->{$ref} > 100) {
				printf "%30s %20s %4u\n", $email, $ref,
					$HoH_refs{$email}->{$ref};
			}
		}
	}

	foreach my $email (sort keys %HoH) {
		$ins_user->execute($email) or
			$ins_user->err == SQLITE_CONSTRAINT_UNIQUE or
			die "cannot execute ins_user: " . $db->errstr;

		foreach my $src (sort keys %{$HoH{$email}}) {
			my ($file, $dir) = fileparse($src);
			$dir =~ s|/$||;
			$ins_ufmap->execute($HoH{$email}{$src},
				$HoH_real{$email}{$src} // 0, $email, $branch,
				$file, $dir) or
				die "cannot execute ins_ufmap";
		}
	}
}

my $branch_no = 0;
my $branch_cnt = scalar @branches;
foreach my $branch (@branches) {
	my $percent = int(100 * ++$branch_no / $branch_cnt);
	my $branch_note = "$branch ($branch_no/$branch_cnt -- $percent %)";
	print colored("== $branch_note -- Starting ==\n", 'green');
	if ($force) {
		$db->do("DELETE FROM branch WHERE branch='$branch';") or
			die "cannot delete branch $branch";
	} else {
		my @one = $db->selectrow_array("SELECT 1 FROM branch WHERE branch='$branch';");

		if (@one and $one[0] == 1) {
			print colored("Already present, skipping, use -f to force re-creation\n", 'yellow');
			next;
		}
	}

	$db->begin_work or die $db->errstr;

	my $branch_dir = $branch;
	$branch_dir =~ s@/@_@g;
	my $branch_tree = "$scratch_area/fill-db-$branch_dir";
	{
		print colored("== $branch_note -- Checking Out ==\n", 'green');
		my $dir = pushd $our_ksource_git;
		$git->command_noisy('checkout', '-q', "origin/$branch");
		my $SHA = $git->command_oneline('rev-parse', 'HEAD');
		$ins_branch->execute($branch, $SHA) or
			die "cannot execute ins_branch";

		print colored("== $branch_note -- Expanding ==\n", 'green');
		system('./scripts/sequence-patch.sh', "--dir=$scratch_area",
			"--patch-dir=$branch_tree", '--rapid') == 0 or
			die "cannot exec sequence-patch";
	}

	print colored("== $branch_note -- Running file2config ==\n", 'green');
	process_files($branch, $branch_tree);

	print colored("== $branch_note -- Detecting authors of patches ==\n", 'green');
	process_authors($branch);

	print colored("== $branch_note -- Committing ==\n", 'green');
	$db->commit or die $db->errstr;
}

END {
        if (defined $db && $db->{Active}) {
		#$db->commit;
                $db->disconnect;
        }
}

